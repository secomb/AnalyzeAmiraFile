/****************************************************************************************
AnalyzeAmiraFile
Postprocessing of spatial graphs generated by Amira from image stacks of microvascular networks
Program to read, process and write Amira spatial graph files (xxxx.Smt.SptGraph.am) and generate Network.dat files.
A set of spatial graphs can be processed. A file called AnalyzeAmiraFileList.dat must be provided,
with the number of files to be processed and a list of the files.
Reading and writing procedures are based on http://www.csc.kth.se/~weinkauf/notes/amiramesh.html
Processing includes the following:
-rejecting edges that are too small in diameter
-rejecting edges that form closed loops
-removing very stubby terminal segments (which may be artifacts of image segmentation)
-combining segments to reach a target length lthresh (also specified in AnalyzeAmiraFileList.dat)
TWS, June 2017
----------------------
Information about file format
.am file header for spatial graph
----------------------
# AmiraMesh BINARY-LITTLE-ENDIAN 2.1

define VERTEX 822
define EDGE 1173
define POINT 22719

Parameters {
    ContentType "HxSpatialGraph"
}

VERTEX { float[3] VertexCoordinates } @1
EDGE { int[2] EdgeConnectivity } @2
EDGE { int NumEdgePoints } @3
POINT { float[3] EdgePointCoordinates } @4
POINT { float thickness } @5

# Data section follows
@1
@2
<binary data section>
-----------------------
The binary data section is written with Little-endian format: This is the memory format of x86 processors and others.
Hence, the data can be read into memory without any modifications on a PC or Intel-based Mac.
**************************************************************************************************/

#define _CRT_SECURE_NO_DEPRECATE

#include <stdio.h>
#include <string.h>
#include <assert.h>
#include <math.h>
#include "nrutil.h"

void write_network(const char fname[]);
void write_amirafile(const char fname[]);
int read_amirafile(const char fname[]);

int nVERTEX,nEDGE,nPOINT,d,isample;
int **EdgeConnectivity,*NumEdgePoints;
float **VertexCoordinates,**EdgePointCoordinates,*thickness;
float lthresh,length,lcumul;

int main()
{
	int j,k,c,igraph,ngraph,nVERTEXnew,nEDGEnew,nPOINTnew,nVERTEX0,nEDGE0,nPOINT0;
	int **EdgeConnectivityNew,*NumEdgePointsNew,*VertexUsed,*EdgeUsed;
	float **VertexCoordinatesNew,**EdgePointCoordinatesNew,*thicknessNew,*thicknessMean;
	char fname0[120],fname1[120],fname2[120];

	FILE* ifp = fopen("AnalyzeAmiraFileList.dat","r");
	fscanf(ifp,"%i%*[^\n]", &ngraph);
	fscanf(ifp,"%f%*[^\n]", &lthresh);	//length threshold for combining segments

	for(igraph=1; igraph<=ngraph; igraph++){
		fscanf(ifp,"%s", &fname0);
		if(read_amirafile(fname0) == 0) printf("*** Error: failed to find file ****\n");
		printf("****************************************************\n");
		printf("Processing spatial graph no. %i: file name %s",igraph,fname0);
		printf("****************************************************\n");

		////Print out a sample of the data
		//   FILE* ofp = fopen("SpatialGraph.out", "w");
		//fprintf(ofp,"@1 VertexCoordinates\n");
		//for(k=1; k<=10; k++){
		//	for(c=1; c<=3; c++) fprintf(ofp,"%f ", VertexCoordinates[k][c]);
		//	fprintf(ofp,"\n");
		//}
		//fprintf(ofp,"@2 EdgeConnectivity\n");
		//for(k=1; k<=10; k++){
		//	for(c=1; c<=2; c++) fprintf(ofp,"%d ", EdgeConnectivity[k][c]);
		//	fprintf(ofp,"\n");
		//}
		//fprintf(ofp,"@3 NumEdgePoints\n");
		//for(k=1; k<=10; k++) fprintf(ofp,"%d\n", NumEdgePoints[k]);
		//fprintf(ofp,"@4 EdgePointCoordinates\n");
		//for(k=1; k<=50; k++){
		//	for(c=1; c<=3; c++) fprintf(ofp,"%f ", EdgePointCoordinates[k][c]);
		//	fprintf(ofp,"\n");
		//}
		//fprintf(ofp,"@5 thickness\n");
		//for(k=1; k<=50; k++) fprintf(ofp,"%f\n", thickness[k]);
		//fclose(ofp);

		//perform desired modifications to spatial graph
		EdgeConnectivityNew = imatrix(1,nEDGE,1,2);
		NumEdgePointsNew = ivector(1,nEDGE);
		VertexUsed = ivector(1,nVERTEX);
		EdgeUsed = ivector(1,nEDGE);
		VertexCoordinatesNew = matrix(1,nVERTEX,1,3);
		EdgePointCoordinatesNew = matrix(1,nPOINT,1,3);
		thicknessNew = vector(1,nPOINT);
		thicknessMean = vector(1,nEDGE);

		nVERTEX0 = nVERTEX;	//save original array dimensions for later freeing
		nEDGE0 = nEDGE;
		nPOINT0 = nPOINT;
		nVERTEXnew = 0;
		nEDGEnew = 0;
		nPOINTnew = 0;

		int *VertexEdge1,iVertex,iEdge,iPoint;
		VertexEdge1 = ivector(1,nVERTEX);
	
		k = 0;	//index of POINT
		for(iEdge=1; iEdge<=nEDGE; iEdge++){
			EdgeUsed[iEdge] = 1;
			thicknessMean[iEdge] = 0.;
			for(j=1; j<=NumEdgePoints[iEdge]; j++){
				k++;
				thicknessMean[iEdge] += thickness[k];
			}
			thicknessMean[iEdge] = thicknessMean[iEdge]/NumEdgePoints[iEdge];
			if(thicknessMean[iEdge] < 1.5) EdgeUsed[iEdge] = 0;	//reject edge if average < 0.75 micron thickness
			if(EdgeConnectivity[iEdge][1] == EdgeConnectivity[iEdge][2]) EdgeUsed[iEdge] = 0;	//reject edge if it is a closed loop
			k -= NumEdgePoints[iEdge];  //reset k
			for(j=1; j<=NumEdgePoints[iEdge]; j++){
				k++;
				thickness[k] = thicknessMean[iEdge];		// set all segments to average thickness
			}
		}
		for(iVertex=1; iVertex<=nVERTEX; iVertex++) VertexUsed[iVertex] = 0;
		//for(i=1; i<=nEDGE; i++)	if(EdgeUsed[i] == 1) for(c=1; c<=2; c++) VertexUsed[EdgeConnectivity[i][c]+1] = 1;
		for(iEdge=1; iEdge<=nEDGE; iEdge++)	if(EdgeUsed[iEdge] == 1) for(c=1; c<=2; c++){	//this version stores the first edge number associated with the vertex
			iVertex = EdgeConnectivity[iEdge][c]+1;
			VertexUsed[iVertex]++;											//and counts the number of associated edges
			if(VertexUsed[iVertex] == 1) VertexEdge1[iVertex] = iEdge;
		}
		for(iVertex=1; iVertex<=nVERTEX; iVertex++) if(VertexUsed[iVertex] == 1){	//if a vertex has only one edge, compute its length
			iEdge = VertexEdge1[iVertex];
			lcumul = 0.;
			for(j=1; j<=NumEdgePoints[iEdge]; j++){
				length = 0.;
				for(c=1; c<=3; c++) length += SQR(EdgePointCoordinates[k][c] - EdgePointCoordinates[k-1][c]);
				length = sqrt(length);
				lcumul += length;
			}
			if(lcumul/thicknessMean[iEdge] < 1. || lcumul/lthresh < 2.){		//if the length is too short relative to diameter, remove the edge and the vertex
				EdgeUsed[iEdge] = 0;
				VertexUsed[iVertex] = 0;
			}
		}
		//for(i=1; i<=nVERTEX; i++) if(VertexUsed[i] == 1){
		for(iVertex=1; iVertex<=nVERTEX; iVertex++) if(VertexUsed[iVertex]){
			nVERTEXnew++;
			VertexUsed[iVertex] = nVERTEXnew;	//create a mapping of old to new vertex numbers
			for(c=1; c<=3; c++) VertexCoordinatesNew[nVERTEXnew][c] = VertexCoordinates[iVertex][c];
		}
		k = 0;	//index of point
		for(iEdge=1; iEdge<=nEDGE; iEdge++){	//index of edge
			if(EdgeUsed[iEdge] == 1){
				nEDGEnew++;
				for(c=1; c<=2; c++) EdgeConnectivityNew[nEDGEnew][c] = VertexUsed[EdgeConnectivity[iEdge][c]+1] - 1;	//use mapping
				NumEdgePointsNew[nEDGEnew]= NumEdgePoints[iEdge];
				for(j=1; j<=NumEdgePoints[iEdge]; j++){
					k++;
					nPOINTnew++;
					for(c=1; c<=3; c++) EdgePointCoordinatesNew[nPOINTnew][c] = EdgePointCoordinates[k][c];
					thicknessNew[nPOINTnew] = thickness[k];
				}
			}
			else k += NumEdgePoints[iEdge];
		}

		if(nEDGEnew <= 0)
			printf("*** error: no edges\n");

		//copy new structure to original arrays
		nEDGE = nEDGEnew;
		nPOINT = nPOINTnew;
		nVERTEX = nVERTEXnew;	   

		for(iVertex=1; iVertex<=nVERTEXnew; iVertex++) for(c=1; c<=3; c++) VertexCoordinates[iVertex][c] = VertexCoordinatesNew[iVertex][c];
		for(iEdge=1; iEdge<=nEDGEnew; iEdge++){
			for(c=1; c<=2; c++) EdgeConnectivity[iEdge][c] = EdgeConnectivityNew[iEdge][c]; 
			NumEdgePoints[iEdge] = NumEdgePointsNew[iEdge];
		}
		for(iVertex=1; iVertex<=nPOINTnew; iVertex++){
			for(c=1; c<=3; c++) EdgePointCoordinates[iVertex][c] = EdgePointCoordinatesNew[iVertex][c];
			thickness[iVertex] = thicknessNew[iVertex];
		}

		//combine segments up to length > lthresh
		nPOINTnew = 0;	//index of new point
		k = 0;	//index of point
		for(iEdge=1; iEdge<=nEDGE; iEdge++){	//index of edge
			lcumul = 0.;
			NumEdgePointsNew[iEdge] = 0;
			for(j=1; j<=NumEdgePoints[iEdge]; j++){
				k++;
				length = 0.;
				if(j > 1){
					for(c=1; c<=3; c++) length += SQR(EdgePointCoordinates[k][c] - EdgePointCoordinates[k-1][c]);
					length = sqrt(length);
					lcumul += length;
				}
				if(j == 1 || j == NumEdgePoints[iEdge] || lcumul > lthresh){	//keep this one
					nPOINTnew++;
					NumEdgePointsNew[iEdge]++;
					for(c=1; c<=3; c++) EdgePointCoordinatesNew[nPOINTnew][c] = EdgePointCoordinates[k][c];
					thicknessNew[nPOINTnew] = thickness[k];
					lcumul = 0.;
				}
			}
		}
		//copy new structure to original arrays
		nPOINT = nPOINTnew;
		for(iEdge=1; iEdge<=nEDGEnew; iEdge++) NumEdgePoints[iEdge] = NumEdgePointsNew[iEdge];
		for(iPoint=1; iPoint<=nPOINTnew; iPoint++){
			for(c=1; c<=3; c++) EdgePointCoordinates[iPoint][c] = EdgePointCoordinatesNew[iPoint][c];
			thickness[iPoint] = thicknessNew[iPoint];
		}
		printf("\treduced nVERTEX: %d\n", nVERTEX);
		printf("\treduced nEDGE: %d\n", nEDGE);
		printf("\treduced nPOINT: %d\n", nPOINT);

		sprintf(fname1,"%sReduced.am",fname0);
		write_amirafile(fname1);
		sprintf(fname2,"%sNetwork.dat",fname0);
		write_network(fname2);

		free_matrix(VertexCoordinates,1,nVERTEX0,1,3);
		free_imatrix(EdgeConnectivity,1,nEDGE0,1,2);
		free_ivector(NumEdgePoints,1,nEDGE0);
		free_matrix(EdgePointCoordinates,1,nPOINT0,1,3);
		free_vector(thickness,1,nPOINT0);
	
		free_imatrix(EdgeConnectivityNew,1,nEDGE0,1,2);
		free_ivector(NumEdgePointsNew,1,nEDGE0);
		free_ivector(VertexUsed,1,nVERTEX0);
		free_ivector(EdgeUsed,1,nEDGE0);
		free_matrix(VertexCoordinatesNew,1,nVERTEX0,1,3);
		free_matrix(EdgePointCoordinatesNew,1,nPOINT0,1,3);
		free_vector(thicknessNew,1,nPOINT0);
	}
    return 0;
}

